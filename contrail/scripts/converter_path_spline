#!/usr/bin/env python2

from math import *

import rospy
from nav_msgs.msg import Path
from contrail_msgs.msg import CubicSpline

global pub_spline

def yaw_from_q(q):
	siny = +2.0 * (q.w * q.z + q.x * q.y);
	cosy = +1.0 - 2.0 * (q.y * q.y + q.z * q.z);
	return atan2(siny, cosy);

def callback_path(msg_in):
	global pub_spline

	# Make sure it is a valid waypoint message
	if (msg_in.header.stamp > rospy.Time(0)) and (len(msg_in.poses) > 0):
		rospy.loginfo("Converting path to spline")

		msg_out = CubicSpline()
		msg_out.header = msg_in.header

		msg_out.x = [0.0]*len(msg_in.poses)
		msg_out.y = [0.0]*len(msg_in.poses)
		msg_out.z = [0.0]*len(msg_in.poses)
		msg_out.yaw = [0.0]*len(msg_in.poses)
		distance = 0.0
		for i in range(len(msg_in.poses)):
			p = msg_in.poses[i].pose

			if(i > 0):
				dx = p.position.x - msg_in.poses[i-1].pose.position.x
				dy = p.position.y - msg_in.poses[i-1].pose.position.y
				dz = p.position.z - msg_in.poses[i-1].pose.position.z
				distance += sqrt(dx*dx + dy*dy + dz*dz)

			msg_out.x[i] = p.position.x
			msg_out.y[i] = p.position.y
			msg_out.z[i] = p.position.z
			msg_out.yaw[i] = yaw_from_q(p.orientation)

		msg_out.start_time = rospy.Time(0)
		msg_out.duration = rospy.Duration(distance/rospy.get_param("~speed", 0.5))

		pub_spline.publish(msg_out)

def waypoint_converter():
	global pub_spline
	rospy.init_node('converter_path_spline', anonymous=True)
	sub_wayp = rospy.Subscriber('~path', Path, callback_path)
	pub_spline = rospy.Publisher('~spline', CubicSpline, queue_size=10, latch=True)

	rospy.loginfo("Path-Spline converter running")

	rospy.spin()

if __name__ == '__main__':
	try:
		waypoint_converter()
	except rospy.ROSInterruptException:
		pass
